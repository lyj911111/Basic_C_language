#include <stdio.h>


/*
	포인터와 배열의 관계
	ex) int arr[3]; 에서 배열의 이름 arr의 자료형은  int * 자료형이다!!!
		배열의 첫번째 요소를 가리키는 포인터다.

	arr 은 상수형태의 포인터이므로 대입연산이 불가능하다.
	-> 예) char arr[30];
		   arr = &p[2]; 이런식의 대입이 불가능하다는 것이다. 상수이므로!! 가리키는 대상을 바꿀수 없다는 것이다.

	※ 포인터 주소값은 변경이 가능하지만, 배열의 이름은 주소값 변경이 불가능.

	질문. 
	
		1. 주소값이 포인터다?   예를들면 0x2450 이 포인터냐?
	답.
		   아니다. 주소값 자체는 포인터가 아니고, " 주소값 + 가리키는 대상 " 이 있어야 포인터다



*/

int main()
{
	int arr1[3] = { 1,2,3 };
	double arr2[3] = { 1.1, 2.2, 3.3 };

	printf("%d , %g \n", arr1, arr2);			// arr1과 arr2 는 단지 상수 주소값을 지님. 0x2345같이
	printf("%d , %g \n", arr1[0], arr2[0]);		// arr1[0] 은 포인터! 즉, 자료형 + 가리키는 대상.
	printf("%d , %g \n", *arr1, *arr2);			// *arr1 도 포인터! 자료형+가리키는 대상

	// 변수 포인터로 배열의 메모리 공간에 접근하여 연산 및 변경
	*arr1 += 100;	//	arr1의 첫번째 값에 +100 연산.
	printf("%d \n",*arr1);

	// 상수포인터 으로 배열 메모리 공간에 접근하여 연산.
	arr1[0] += 100; //  arr1의 첫번째 값에 +100 연산.
	printf("%d \n",*arr1);


	// (포인터 연산 연습.............)

	*arr2 += 3.42;
	printf("%g \n", *arr2);
	printf("%g \n", *(arr2 + 1));	//	두번째 배열이 출력
	
	*(arr2 + 2) += 5.5;				//	arr2의 3번째 배열에 가서 5.5를 더해라
	printf("%g \n", *arr2 + 2);		//	연산결과 확인.


	return 0;
}